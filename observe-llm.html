<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-ko="observe-llm: 운영 가능한 Self-Correcting AI Agent" data-en="observe-llm: A Production-Ready, Self-Correcting AI Agent">observe-llm: 운영 가능한 Self-Correcting AI Agent</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans KR', sans-serif;
            background-color: #f8fafc; /* slate-50 */
        }
        .code-block {
            background-color: #1e293b; /* slate-800 */
            color: #e2e8f0; /* slate-200 */
            border-radius: 0.5rem;
            padding: 1rem;
            position: relative;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
            cursor: pointer;
        }
        .code-block pre { margin: 0; }
        .section-title-icon {
            width: 2.5rem; height: 2.5rem; margin-right: 1rem; color: #4f46e5; /* indigo-600 */
        }
        html { scroll-behavior: smooth; }
        section { scroll-margin-top: 5rem; }
        .prose h2 { font-size: 1.875rem; font-weight: 700; margin-bottom: 1.5rem; }
        .prose h3 { font-size: 1.5rem; font-weight: 600; margin-top: 2rem; margin-bottom: 1rem; }
        .prose p, .prose ul, .prose li { color: #475569; line-height: 1.75; }
        .prose a { color: #4f46e5; text-decoration: none; }
        .prose a:hover { text-decoration: underline; }
        .prose strong { color: #1e293b; }
        .lang-toggle button.active {
            background-color: #4f46e5;
            color: white;
        }
    </style>
</head>
<body class="text-slate-800">

    <!-- Language Toggle -->
    <div class="fixed top-4 right-4 z-50 lang-toggle bg-white shadow-lg rounded-full p-1 flex space-x-1">
        <button id="btn-ko" class="px-3 py-1 text-sm font-semibold rounded-full transition-colors duration-200 active" onclick="switchLanguage('ko')">한국어</button>
        <button id="btn-en" class="px-3 py-1 text-sm font-semibold rounded-full transition-colors duration-200" onclick="switchLanguage('en')">English</button>
    </div>

    <div class="container mx-auto px-4 py-12 md:py-16">
        <!-- Header -->
        <header class="text-center mb-12 md:mb-20">
            <h1 class="text-4xl md:text-6xl font-bold text-slate-900 mb-4">observe-llm</h1>
            <p class="text-xl text-slate-600 max-w-3xl mx-auto" data-ko="운영 환경을 고려한 Self-Correcting AI Agent와 완전한 관찰 가능성" data-en="A Production-Ready, Self-Correcting AI Agent with Full Observability">
                운영 환경을 고려한 Self-Correcting AI Agent와 완전한 관찰 가능성
            </p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
            <!-- Sidebar Navigation -->
            <aside class="lg:col-span-3 lg:sticky top-8 self-start">
                <nav class="bg-white p-4 rounded-lg shadow-sm">
                    <h3 class="font-bold text-lg mb-4 text-slate-900" data-ko="목차" data-en="Table of Contents">목차</h3>
                    <ul class="space-y-2">
                        <li><a href="#introduction" class="text-slate-600 hover:text-indigo-600 block" data-ko="1. 프로젝트 소개" data-en="1. Introduction">1. 프로젝트 소개</a></li>
                        <li><a href="#architecture" class="text-slate-600 hover:text-indigo-600 block" data-ko="2. 시스템 아키텍처" data-en="2. System Architecture">2. 시스템 아키텍처</a></li>
                        <li><a href="#deep-dive" class="text-slate-600 hover:text-indigo-600 block" data-ko="3. 코드 분석" data-en="3. Code Deep Dive">3. 코드 분석</a></li>
                        <li><a href="#deployment-ops" class="text-slate-600 hover:text-indigo-600 block" data-ko="4. 배포 및 운영 전략" data-en="4. Deployment & Ops">4. 배포 및 운영 전략</a></li>
                        <li><a href="#future-work" class="text-slate-600 hover:text-indigo-600 block" data-ko="5. 향후 방향" data-en="5. Future Work">5. 향후 방향</a></li>
                    </ul>
                </nav>
            </aside>

            <!-- Main Content -->
            <main class="lg:col-span-9 space-y-16">
                
                <div class="prose">
                    <section id="introduction">
                        <h2 data-ko="1. 소개: 프로토타입을 넘어서" data-en="1. Introduction: Beyond the Prototype">1. 소개: 프로토타입을 넘어서</h2>
                        <p data-ko="많은 AI 에이전트 프로젝트는 개념 증명(PoC) 단계에 머물러 있습니다. 핵심 기능은 보여주지만, 배포, 모니터링, 확장성이라는 중요한 측면을 간과하는 경우가 많습니다. `observe-llm`은 이 간극을 메우기 위해 만들어졌습니다. 단순한 스크립트를 넘어, 견고하고 운영 가능한(production-ready) AI 에이전트 시스템을 구축하는 방법을 보여주는 실용적인 오픈소스 예제입니다." data-en="Many AI agent projects remain at the proof-of-concept stage. They demonstrate a core capability but often overlook the crucial aspects of deployment, monitoring, and scalability. `observe-llm` was created to bridge this gap. It's a practical, open-source example that goes beyond a simple script to showcase how to build a robust, production-ready AI agent system.">
                            많은 AI 에이전트 프로젝트는 개념 증명(PoC) 단계에 머물러 있습니다. 핵심 기능은 보여주지만, 배포, 모니터링, 확장성이라는 중요한 측면을 간과하는 경우가 많습니다. `observe-llm`은 이 간극을 메우기 위해 만들어졌습니다. 단순한 스크립트를 넘어, 견고하고 운영 가능한(production-ready) AI 에이전트 시스템을 구축하는 방법을 보여주는 실용적인 오픈소스 예제입니다.
                        </p>
                        <h3 data-ko="왜 Langfuse가 필수적인가?" data-en="Why is Langfuse Essential?">왜 Langfuse가 필수적인가?</h3>
                        <p data-ko="단순한 LLM 체인은 디버깅하기 쉽지만, 순환적인 Self-Correcting 루프를 가진 에이전트는 '블랙박스'가 될 수 있습니다. Langfuse는 에이전트의 모든 생각과 행동에 대한 깊은 통찰력을 제공하여, 복잡한 AI 워크플로우의 <strong>관찰 가능성(observability)</strong> 문제를 해결합니다." data-en="While simple LLM chains are easy to debug, agents with cyclical, self-correcting loops can become 'black boxes.' Langfuse solves the challenge of <strong>observability in complex AI workflows</strong> by providing deep insights into every thought and action of the agent.">
                            단순한 LLM 체인은 디버깅하기 쉽지만, 순환적인 Self-Correcting 루프를 가진 에이전트는 '블랙박스'가 될 수 있습니다. Langfuse는 에이전트의 모든 생각과 행동에 대한 깊은 통찰력을 제공하여, 복잡한 AI 워크플로우의 <strong>관찰 가능성(observability)</strong>문제를 해결합니다.
                        </p>
                         <ul>
                            <li data-ko="<strong>사용자별 비용 추적:</strong> `user_id`를 기준으로 각 API 호출의 비용을 정확하게 추적하여 사용자별 과금의 기반을 마련할 수 있습니다." data-en="<strong>Cost Tracking per User:</strong> Accurately track the cost of each API call on a per-user basis, laying the groundwork for user-based billing.">
                                <strong>사용자별 비용 추적:</strong> `user_id`를 기준으로 각 API 호출의 비용을 정확하게 추적하여 사용자별 과금의 기반을 마련할 수 있습니다.
                            </li>
                            <li data-ko="<strong>성능 병목 분석:</strong> LLM 모델별, 에이전트의 각 노드(단계)별 평균 지연 시간(latency)과 토큰 사용량을 분석하여 어느 부분에서 시간이 오래 걸리는지, 어떤 모델이 비효율적인지 쉽게 파악할 수 있습니다." data-en="<strong>Performance Bottleneck Analysis:</strong> Analyze average latency and token usage per LLM model and per agent node (step) to easily identify bottlenecks and inefficient models.">
                                <strong>성능 병목 분석:</strong> LLM 모델별, 에이전트의 각 노드(단계)별 평균 지연 시간(latency)과 토큰 사용량을 분석하여 어느 부분에서 시간이 오래 걸리는지, 어떤 모델이 비효율적인지 쉽게 파악할 수 있습니다.
                            </li>
                            <li data-ko="<strong>품질 평가:</strong> 프롬프트의 버전을 관리하고, 동일한 입력에 대해 다른 프롬프트나 모델 버전이 어떻게 다른 결과물을 내놓는지 A/B 테스트하며, 사용자 피드백을 수집하여 에이전트의 응답 품질을 정량적으로 평가할 수 있습니다." data-en="<strong>Quality Evaluation:</strong> Manage prompt versions, A/B test different prompts or models on the same input, and collect user feedback to quantitatively assess the quality of the agent's responses.">
                                <strong>품질 평가:</strong> 프롬프트의 버전을 관리하고, 동일한 입력에 대해 다른 프롬프트나 모델 버전이 어떻게 다른 결과물을 내놓는지 A/B 테스트하며, 사용자 피드백을 수집하여 에이전트의 응답 품질을 정량적으로 평가할 수 있습니다.
                            </li>
                            <li data-ko="<strong>신속한 디버깅:</strong> 복잡한 에이전트의 실행 흐름 전체를 시각적인 트레이스로 한눈에 파악하여, 어느 단계에서 문제가 발생했는지 신속하게 디버깅할 수 있습니다." data-en="<strong>Rapid Debugging:</strong> Gain a clear, visual trace of the entire complex agent workflow, allowing for quick identification and debugging of issues at any step.">
                                <strong>신속한 디버깅:</strong> 복잡한 에이전트의 실행 흐름 전체를 시각적인 트레이스로 한눈에 파악하여, 어느 단계에서 문제가 발생했는지 신속하게 디버깅할 수 있습니다.
                            </li>
                        </ul>
                    </section>
                </div>

                <div class="w-full my-8 rounded-lg overflow-hidden shadow-lg">
                    <div class="relative" style="padding-top: 41.875%;">
                      <iframe src="https://www.youtube.com/embed/R5ympCEcl2o?autoplay=1&loop=1&mute=1&playlist=R5ympCEcl2o&controls=0&showinfo=0&autohide=1" 
                        frameborder="0" 
                        allow="autoplay; encrypted-media" 
                        allowfullscreen
                        class="absolute top-0 left-0 w-full h-full">
                      </iframe>
                    </div>
                </div>

                <div class="prose">
                    <section id="architecture">
                        <h2 data-ko="2. 시스템 아키텍처: 전체적인 관점" data-en="2. System Architecture: A Holistic View">2. 시스템 아키텍처: 전체적인 관점</h2>
                        <p data-ko="에이전트 자체는 퍼즐의 한 조각에 불과합니다. 견고한 시스템은 지원 서비스의 전체 스택을 필요로 하며, 이 모든 것이 원활하게 조율되어야 합니다. 저희는 Docker Compose를 사용하여 이 생태계를 관리하며, 여기에는 다음이 포함됩니다:" data-en="The agent itself is just one piece of the puzzle. A robust system requires a full stack of supporting services, all orchestrated seamlessly. We use Docker Compose to manage this ecosystem, which includes:">
                            에이전트 자체는 퍼즐의 한 조각에 불과합니다. 견고한 시스템은 지원 서비스의 전체 스택을 필요로 하며, 이 모든 것이 원활하게 조율되어야 합니다. 저희는 Docker Compose를 사용하여 이 생태계를 관리하며, 여기에는 다음이 포함됩니다:
                        </p>
                        <div class="mermaid" style="width: 100%; background-color: white; padding: 1rem; border-radius: 0.5rem;">
                            graph TD
                                subgraph User
                                    A[Browser]
                                end
                                subgraph Docker Network
                                    B(observe-llm Agent) -- HTTP Request --> A
                                    B -- Trace Data --> C(Langfuse Server)
                                    C -- Writes/Reads --> D(PostgreSQL)
                                    C -- Writes/Reads --> E(Clickhouse)
                                    C -- Uses --> F(Redis)
                                    C -- Uses --> G(Minio)
                                end
                                A -- Interacts --> B
                        </div>
                        <p class="text-sm text-center mt-2 text-slate-500" data-ko="그림 1: Docker Compose로 관리되는 전체 시스템 아키텍처" data-en="Figure 1: Overall system architecture managed by Docker Compose.">
                            그림 1: Docker Compose로 관리되는 전체 시스템 아키텍처
                        </p>
                    </section>

                    <section id="deep-dive">
                        <h2 data-ko="3. 코드 분석: Self-Correcting Loop" data-en="3. Code Deep Dive: The Self-Correcting Loop">3. 코드 분석: Self-Correcting Loop</h2>
                        <p data-ko="핵심 로직은 `run_agent.py`에 있습니다. LangGraph를 사용하여 인간이 글을 다듬는 과정을 모방한 순환적인 '비평 및 수정' 워크플로우를 가능하게 하는 상태 머신을 만듭니다." data-en="The core logic resides in `run_agent.py`. It uses LangGraph to create a state machine that enables a cyclical 'critique and revision' workflow, mimicking how a human might refine a piece of writing.">
                            핵심 로직은 `run_agent.py`에 있습니다. LangGraph를 사용하여 인간이 글을 다듬는 과정을 모방한 순환적인 '비평 및 수정' 워크플로우를 가능하게 하는 상태 머신을 만듭니다.
                        </p>
                        <div class="mermaid" style="width: 100%; background-color: white; padding: 1rem; border-radius: 0.5rem;">
                            graph TD
                                Start --> Researcher
                                Researcher --> Writer
                                Writer --> Critique
                                Critique -- REVISE --> Reviser
                                Reviser --> Critique
                                Critique -- APPROVE --> SetFinalOutput
                                SetFinalOutput --> End
                        </div>
                         <p class="text-sm text-center mt-2 text-slate-500" data-ko="그림 2: LangGraph 에이전트의 워크플로우" data-en="Figure 2: The LangGraph agent's workflow.">
                            그림 2: LangGraph 에이전트의 워크플로우
                        </p>
                        <h3 data-ko="상태 머신 (`AgentState`)" data-en="The State Machine (`AgentState`)">상태 머신 (`AgentState`)</h3>
                        <p data-ko="`AgentState` TypedDict는 에이전트의 생명선입니다. 그래프의 각 노드가 읽고 쓰는 공유 메모리 역할을 하여 워크플로우 전반에 걸쳐 원활한 정보 흐름을 보장합니다." data-en="The `AgentState` TypedDict is the lifeblood of the agent. It's a shared memory that each node in the graph reads from and writes to, ensuring a seamless flow of information through the workflow.">
                            `AgentState` TypedDict는 에이전트의 생명선입니다. 그래프의 각 노드가 읽고 쓰는 공유 메모리 역할을 하여 워크플로우 전반에 걸쳐 원활한 정보 흐름을 보장합니다.
                        </p>
                        <div class="code-block" onclick="selectCode(this)">
                            <pre><code>class AgentState(TypedDict):
    topic: str
    research_result: str
    draft: str
    critique: str
    # ... and other state variables
</code></pre>
                        </div>
                        <h3 data-ko="조건부 엣지의 역할" data-en="The Role of the Conditional Edge">조건부 엣지의 역할</h3>
                        <p data-ko="이 워크플로우의 핵심은 `Critique` 노드 이후의 분기입니다. `should_revise` 함수는 `critique`의 내용에 'REVISE'라는 키워드가 있는지 확인하여, 에이전트가 수정을 계속할지 아니면 작업을 완료할지를 동적으로 결정합니다. 이 조건부 라우팅이 바로 LangGraph의 강력함입니다." data-en="The magic of this workflow is the branch after the `Critique` node. The `should_revise` function checks for the keyword 'REVISE' in the critique's output to dynamically decide whether the agent should continue revising or finalize its work. This conditional routing is the power of LangGraph.">
                            이 워크플로우의 핵심은 `Critique` 노드 이후의 분기입니다. `should_revise` 함수는 `critique`의 내용에 'REVISE'라는 키워드가 있는지 확인하여, 에이전트가 수정을 계속할지 아니면 작업을 완료할지를 동적으로 결정합니다. 이 조건부 라우팅이 바로 LangGraph의 강력함입니다.
                        </p>
                        <div class="code-block" onclick="selectCode(this)">
                            <pre><code>def should_revise(state: AgentState) -> str:
    if "REVISE" in state["critique"]:
        return "reviser"  # Loop back to revise
    else:
        return "set_final_output" # Exit the loop
</code></pre>
                        </div>
                    </section>

                    <section id="deployment-ops">
                        <h2 data-ko="4. 개발에서 배포까지" data-en="4. From Development to Distribution">4. 개발에서 배포까지</h2>
                        <p data-ko="이 프로젝트를 진정으로 운영 가능하게 만들기 위해 몇 가지 핵심적인 운영 전략이 구현되었습니다." data-en="To make this project truly production-ready, several key operational strategies were implemented.">
                            이 프로젝트를 진정으로 운영 가능하게 만들기 위해 몇 가지 핵심적인 운영 전략이 구현되었습니다.
                        </p>
                        <h3 data-ko="보안 및 구성" data-en="Security & Configuration">보안 및 구성</h3>
                        <p data-ko="API 키와 같은 모든 민감 정보는 `.env` 파일을 통해 관리됩니다. `docker-compose.yml`은 이러한 변수를 참조하여 소스 코드에 비밀이 하드코딩되지 않도록 합니다. `.gitignore` 파일은 `.env` 파일이 버전 제어에 커밋되는 것을 방지합니다." data-en="All sensitive information, such as API keys, is managed through a `.env` file. The `docker-compose.yml` references these variables, ensuring that no secrets are hardcoded in the source code. The `.gitignore` file prevents the `.env` file from ever being committed to version control.">
                            API 키와 같은 모든 민감 정보는 `.env` 파일을 통해 관리됩니다. `docker-compose.yml`은 이러한 변수를 참조하여 소스 코드에 비밀이 하드코딩되지 않도록 합니다. `.gitignore` 파일은 `.env` 파일이 버전 제어에 커밋되는 것을 방지합니다.
                        </p>
                        <h3 data-ko="데이터 영속성" data-en="Data Persistence">데이터 영속성</h3>
                        <p data-ko="Langfuse 스택은 영구 데이터를 필요로 합니다. 임시 Docker 볼륨 대신, 시스템은 로컬 바인드 마운트로 구성됩니다. 모든 데이터는 로컬 머신의 `langfuse-data/` 디렉토리에 저장되어, 컨테이너 재시작 및 제거에도 추적 기록이 유지됩니다." data-en="The Langfuse stack requires persistent data. Instead of using ephemeral Docker volumes, the system is configured with local bind mounts. All data is saved to a `langfuse-data/` directory on your local machine, guaranteeing that your trace history survives container restarts and removals.">
                            Langfuse 스택은 영구 데이터를 필요로 합니다. 임시 Docker 볼륨 대신, 시스템은 로컬 바인드 마운트로 구성됩니다. 모든 데이터는 로컬 머신의 `langfuse-data/` 디렉토리에 저장되어, 컨테이너 재시작 및 제거에도 추적 기록이 유지됩니다.
                        </p>
                    </section>

                    <section id="future-work">
                        <h2 data-ko="5. 향후 방향 및 고도화" data-en="5. Future Directions & Enhancements">5. 향후 방향 및 고도화</h2>
                        <p data-ko="`observe-llm`은 견고한 기반을 제공하지만, 확장할 수 있는 흥미로운 방법이 많이 있습니다:" data-en="`observe-llm` provides a solid foundation, but there are many exciting ways it could be extended:">
                            `observe-llm`은 견고한 기반을 제공하지만, 확장할 수 있는 흥미로운 방법이 많이 있습니다:
                        </p>
                        <ul>
                            <li data-ko="<strong>에이전트 도구 추가:</strong> `researcher` 노드에 웹 검색 API(예: Tavily)와 같은 도구를 제공하여 기능을 향상시킬 수 있습니다. 이를 통해 에이전트는 실시간 정보를 통합하고 더 강력한 팩트체크를 수행할 수 있습니다." data-en="<strong>Agent Tooling:</strong> Enhance the `researcher` node by giving it access to tools, such as a web search API (e.g., Tavily). This would allow the agent to incorporate real-time information and perform more robust fact-checking.">
                                <strong>에이전트 도구 추가:</strong> `researcher` 노드에 웹 검색 API(예: Tavily)와 같은 도구를 제공하여 기능을 향상시킬 수 있습니다. 이를 통해 에이전트는 실시간 정보를 통합하고 더 강력한 팩트체크를 수행할 수 있습니다.
                            </li>
                            <li data-ko="<strong>인간 참여 루프(Human-in-the-Loop):</strong> Langfuse의 사용자 피드백 기능을 통합합니다. 에이전트가 수정 루프를 완료한 후, 최종 초안을 인간에게 제시하여 최종 '승인' 또는 '거절' 조치를 받게 하고, 이 피드백을 Langfuse에 기록하여 에이전트의 성능을 추가로 평가할 수 있습니다." data-en="<strong>Human-in-the-Loop:</strong> Integrate Langfuse's user feedback features. After the agent completes its revision loop, the final draft could be presented to a human for a final 'approve' or 'reject' action, with that feedback being logged in Langfuse to further evaluate the agent's performance.">
                                <strong>인간 참여 루프(Human-in-the-Loop):</strong> Langfuse의 사용자 피드백 기능을 통합합니다. 에이전트가 수정 루프를 완료한 후, 최종 초안을 인간에게 제시하여 최종 '승인' 또는 '거절' 조치를 받게 하고, 이 피드백을 Langfuse에 기록하여 에이전트의 성능을 추가로 평가할 수 있습니다.
                            </li>
                            <li data-ko="<strong>자동화된 테스트 및 평가:</strong> Langfuse의 데이터셋 및 점수 기능을 사용하여 자동화된 평가 파이프라인을 만듭니다. 주제와 예상 요점의 데이터셋을 구축한 다음, 이 데이터셋에 대해 에이전트를 프로그래밍 방식으로 실행하여 시간 경과에 따른 정확성과 일관성을 점수화할 수 있습니다." data-en="<strong>Automated Testing & Evaluation:</strong> Use Langfuse's dataset and scoring features to create an automated evaluation pipeline. We could build a dataset of topics and expected key points, and then programmatically run the agent against this dataset to score its accuracy and consistency over time.">
                                <strong>자동화된 테스트 및 평가:</strong> Langfuse의 데이터셋 및 점수 기능을 사용하여 자동화된 평가 파이프라인을 만듭니다. 주제와 예상 요점의 데이터셋을 구축한 다음, 이 데이터셋에 대해 에이전트를 프로그래밍 방식으로 실행하여 시간 경과에 따른 정확성과 일관성을 점수화할 수 있습니다.
                            </li>
                        </ul>
                    </section>
                </div>
            </main>
        </div>
        
        <footer class="text-center mt-20 text-slate-500">
            <p>&copy; 2025 jae-choi. All rights reserved.</p>
        </footer>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'neutral' });

        function selectCode(element) {
            const range = document.createRange();
            range.selectNodeContents(element.querySelector('code'));
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
        }

        function switchLanguage(lang) {
            document.querySelectorAll('[data-ko]').forEach(el => {
                if (el.dataset[lang]) {
                    el.innerHTML = el.dataset[lang];
                }
            });
            document.documentElement.lang = lang;
            document.getElementById('btn-ko').classList.toggle('active', lang === 'ko');
            document.getElementById('btn-en').classList.toggle('active', lang === 'en');
        }
        // Set initial language
        switchLanguage('ko');
    </script>

</body>
</html>
